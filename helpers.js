const { Datastore } = require('@google-cloud/datastore');
const { OAuth2Client } = require('google-auth-library');
const shell = require("shelljs");

/**
 * Checks if a user is already logged in. If a user tried to
 *  access the main page directly, redirect them here
 * @param {*} req 
 * @param {*} res 
 * @param {*} next 
 */
function checkLoggedIn(req, res, next) {
    if (req.session.loggedIn || req.path == '/login') {
        next();
    } else {
        res.redirect("/login");
    }
}

/**
 * Verifies the user's identity based off Google OAuth2
 * @param {*} credential 
 * @param {*} clientid 
 * @returns 
 */
async function verifyLogin(credential, clientid) {
    const client = new OAuth2Client(clientid);
    const ticket = await client.verifyIdToken({
        idToken: credential,
        audience: clientid
    });
    const payload = ticket.getPayload();
    const userinfo = {
        fullname: payload.name,
        givenname: payload.given_name,
        email: payload.email,
        uid: payload.sub,
    };
    return userinfo;
}


/**
 * Using the pentest tool to generate a JSON vulnerabilty
 *  report for a given website 
 * @param {*} targetURL 
 * @returns 
 */
async function convertUrlToJson(targetURL) {
    let outputJson = await shell.exec(`pentest-tool-lite ${targetURL} --reportFormat JSON`,);
    outputJson = outputJson.toString()
        .substring(outputJson.toString().indexOf("["))
    return outputJson;
}

/**
 * Fetches all scans done by a specific user from
 *  the Google Cloud Datastore
 * @param {*} datastore 
 * @param {*} owner 
 * @returns 
 */
async function fetchScans(datastore, owner) {
    const scansQuery = datastore
        .createQuery('Scan')
        .filter('owner', '=', owner.toString());
    let [scans] = await datastore.runQuery(scansQuery);
    for (const scan of scans) {
        [scan.url] = await datastore.keyToLegacyUrlSafe(scan[Datastore.KEY]);
    }
    return scans;
}


/**
 * Gets a single scan from the Google Cloud Datastore
 * @param {*} datastore 
 * @param {*} urlsafekey 
 * @returns 
 */
async function fetchScan(datastore, urlsafekey) {
    const scanKey = datastore.keyFromLegacyUrlsafe(urlsafekey);
    const scanQuery = datastore
        .createQuery('Scan')
        .filter('__key__', '=', scanKey);
    let [[scan]] = await datastore.runQuery(scanQuery);
    scan.url = urlsafekey;
    return scan;
}

/**
 * Inserts a new scan into the Google Cloud Datastore
 * @param {*} datastore 
 * @param {*} scanToInsert 
 * @returns 
 */
async function insertScan(datastore, scanToInsert) {
    const scanKey = datastore.key('Scan');
    const entity = {
        key: scanKey,
        data: scanToInsert
    };
    await datastore.insert(entity);
    [scanToInsert.url] = await datastore.keyToLegacyUrlSafe(scanKey);
    return scanToInsert;
}

/**
 * Deletes a scan from the Google Cloud Datastore
 * @param {*} datastore 
 * @param {*} scanToDelete 
 */
async function deleteScan(datastore, scanToDelete) {
    const keyToDelete = datastore.keyFromLegacyUrlsafe(scanToDelete.url);
    await datastore.delete(keyToDelete);
}

/**
 * Helper method to update the line of the generated report which has bee nuplloaded to the gcloud 
 * @param {*} datastore 
 * @param {*} bucketName 
 * @param {*} Scan 
 */
async function updateScanReportURL(datastore, bucketName, Scan) {
    const oldScan = await fetchScan(datastore, Scan.url);
    oldScan.scanReportURL = "https://storage.googleapis.com/" + bucketName + "/" + 
        Scan.url + Scan.owner + '-wvsresult.txt';
    await datastore.update(oldScan);
}

/**
 * Creates the header of a Report, returns it as a String
 * @param {*} jsonReport 
 * @returns 
 */
function createTxtReport(jsonReport) {
    let newReport = `Save this report with CTRL S, or right click on this ` +
        `page and click "Save Page As", or "Save As", depending on your ` +
        `browser.\n\n` +
        `The following is a WVS Report for: ${jsonReport.URL}\n\n` +
        `Security`;
    newReport = jsonDelimiter(newReport, jsonReport.Security);
    return newReport;
}

/**
 * Loops through a given JSON object retrieved using the pentest tool
 *  and writes all data retrieved, including titles, statuses, and
 *  descriptions. Formats information in tables and bulleted lists.
 *  Returns the information as a string to be written to the text
 *  document
 * @param {*} newReport 
 * @param {*} objToDelimit 
 * @returns 
 */
function jsonDelimiter(newReport, objToDelimit) {
    if (objToDelimit) {
        newReport += `\nTitle\t\t\t\t\tStatus\n`;
        for (let i = 0; i < objToDelimit.length; i++) {
            newReport += `${objToDelimit[i].title}`
            const numTabs = 5 - (objToDelimit[i].title.length / 8);
            for (let j = 0; j < numTabs; j++) {
                newReport += `\t`;
            }
            newReport += `${objToDelimit[i].status}\n`;
        };
        let descriptionsExist = 0;
        for (let i = 0; i < objToDelimit.length; i++) {
            if (objToDelimit[i].description !== "") {
                descriptionsExist++;
                if (descriptionsExist == 1) {
                    newReport += `\nDescriptions:\n`;
                }
                newReport += `- ${objToDelimit[i].title}: ` +
                    `${objToDelimit[i].description}\n`;
            }
        };
        if (descriptionsExist == 0) {
            newReport += `\nNo Descriptions Available.\n`;
        }
        newReport += `\n`;
        return newReport;
    } else {
        newReport += `\nNothing to Report\n\n`;
        return newReport;
    }
}

exports.checkLoggedIn = checkLoggedIn;
exports.verifyLogin = verifyLogin;
exports.convertUrlToJson = convertUrlToJson;
exports.fetchScans = fetchScans;
exports.fetchScan = fetchScan;
exports.insertScan = insertScan;
exports.deleteScan = deleteScan;
exports.updateScanReportURL = updateScanReportURL;
exports.createTxtReport = createTxtReport;
exports.jsonDelimiter = jsonDelimiter;