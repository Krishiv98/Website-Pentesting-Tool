/**
 * Authors: Reese Lippai & Krishiv Soni
 */

const express = require("express");
const session = require('express-session');
const helpers = require('./helpers.js');
const bodyParser = require('body-parser');
const {Datastore} = require('@google-cloud/datastore');
const {Storage} = require('@google-cloud/storage');
const fs = require('fs');
const app = express();
const TMPREPORTDIR = process.env.NODE_ENV == "production" ? "/tmp" : __dirname + "/tmp";

// const BUCKET = "thermal-yeti-387219.appspot.com"
const BUCKET = "aerial-rarity-387219.appspot.com";

// Reese's Gcloud Creds
process.env.APPURL = "https://aerial-rarity-387219.uc.r.appspot.com"
process.env.CLIENTID = "408671005868-ffsmmkum5dkrt3t4hh3uhlkj4q5sqign.apps.googleusercontent.com"

// Krishiv's Gcloud creds
// process.env.APPURL = "https://thermal-yeti-387219.ey.r.appspot.com"
// process.env.CLIENTID =  "545274653748-i42s5n190q3okluuvqsgocidnik1j5g2.apps.googleusercontent.com"

//Setting up the Connections 
const PORT = process.env.PORT || 8080;
const CLIENTID = process.env.CLIENTID;
const APPURL = process.env.APPURL || "https://localhost:" + PORT;

// GCloud storage connections
const datastore = new Datastore();
const storage = new Storage();

// Middleware
app.use(function(req,res,next) {
  if (process.env.NODE_ENV != "production") {
      res.setHeader('Referrer-Policy', 'no-referrer-when-downgrade');
  }
  next();
})
app.use(express.static('public'))
app.use(bodyParser.urlencoded({extended: true}))
app.use(session({
  secret: 'secret',
  resave: true,
  saveUninitialized: true,
  unset: 'destroy',
}))

// Immediately redirect to helpers
app.use(helpers.checkLoggedIn);
app.set('view engine', 'ejs');

// Routes

/**
 * HOME GET ROUTE
 */
app.get('/', async (req,res) => {
  // Fetch list of scans
  let scansForUser = await helpers.fetchScans(datastore, req.session.userid);
  res.render('index.ejs', { name: req.session.username, userScans: scansForUser});
})

/**
 * DELETE ROUTE
 */
app.delete('/scans/:url', async (req,res) => {
  // Fetch scan to delete and reconstruct bucket url
  let scan = await helpers.fetchScan(datastore, req.params.url)
  const bucketLink = scan.url + scan.owner + "-wvsresult.txt";

  // Delete entity from Datastore AND the related report from Bucket
  await helpers.deleteScan(datastore, {url: req.params.url});
  await storage.bucket(BUCKET).file(bucketLink).delete();

  res.json("deleted title " + req.params.url);
})

// POST after scans complete
app.post('/scan', async (req,res) => {
  let newScan = {
      owner: req.session.userid.toString(),
      targetURL: req.body.targetURL,
  };

  // Run the pentesting tool to get the report in JSON format
  let reportJson = await helpers.convertUrlToJson(newScan.targetURL);
  reportJson = JSON.parse(reportJson);

  // Reformatting the JSON to be used in the report
  const reformatJson = {
    Security: reportJson[0].results,
    HTML: reportJson[1].results,
    Wordpress: reportJson[2].results,
    URL: newScan.targetURL
  }

  // Getting the statistics of the scan to show the user on the results screen
  const jsonStats = {
    security:   reportJson[0].results.filter(x => x.status === "ERROR").length,
    html:       reportJson[1].results.filter(x => x.status === "ERROR").length,
    css:        reportJson[1].results[1].results.filter(x => x.status === "ERROR").length,
    image:      reportJson[1].results[2].results.filter(x => x.status === "ERROR").length,
    wordpress:  reportJson[2].results.filter(x => x.status === "ERROR").length,
  }

  // Some website have JavaScript hidden
  if (reportJson[1].results[0].results) { 
    jsonStats.javascript = reportJson[1].results[0].results.filter(x => x.status === "ERROR").length
  } else {
    jsonStats.javascript = 0;
  }

  // Getting the name of the site scanned
  let siteName = newScan.targetURL.toString()
  siteName = siteName.substring(siteName.lastIndexOf('//') + 2, siteName.lastIndexOf('.'));

  // Creating path name for report
  let tempReportFilePath = TMPREPORTDIR + "/" + req.session.userid.toString()+"-"+siteName+'-wvsresult.txt';

  // Generating the report for the website and saving it into the temp folder (as txt)
  await fs.writeFileSync(tempReportFilePath, 
    helpers.createTxtReport(reformatJson));
  await fs.appendFileSync(tempReportFilePath, 
    helpers.jsonDelimiter("HTML", reformatJson.HTML));
  await fs.appendFileSync(tempReportFilePath, 
    helpers.jsonDelimiter("JavaScript", reformatJson.HTML[0].results));
  await fs.appendFileSync(tempReportFilePath, 
    helpers.jsonDelimiter("CSS", reformatJson.HTML[1].results));
  await fs.appendFileSync(tempReportFilePath, 
    helpers.jsonDelimiter("Image", reformatJson.HTML[2].results));
  await fs.appendFileSync(tempReportFilePath, 
    helpers.jsonDelimiter("Wordpress", reformatJson.Wordpress));
  await fs.appendFileSync(tempReportFilePath, 
    "The Website Vulnerability Scanner TM");

  // Adding new properties to the scan before adding it to the datastore
  newScan.scanDate = new Date()
  newScan.scanReportURL = tempReportFilePath
  newScan.jsonStats = jsonStats

  // Add the scan to the datastore
  const insertedScan = await helpers.insertScan(datastore, newScan);

  // Generating the bucket link & options for the txt file report
  const destFileNameForReport = insertedScan.url + insertedScan.owner +'-wvsresult.txt'
  const options ={
    destination: destFileNameForReport,
  }

  // Sending the report to the Bucket
  await storage.bucket(BUCKET).upload(tempReportFilePath, options);

  // Updating the report's url in the assosicated entity so that the user can download it
  await helpers.updateScanReportURL(datastore, BUCKET, insertedScan)

  // Deleting the txt file from the tmp folder
  await fs.rmSync(tempReportFilePath);
  
  // Render the result page
  res.render('results.ejs', {jsonStats: jsonStats, pageBucketLink: "https://storage.googleapis.com/" + 
    BUCKET + "/" + destFileNameForReport, 
    totalErs: jsonStats.security + jsonStats.html + jsonStats.javascript + jsonStats.css
     + jsonStats.image + jsonStats.wordpress});
})

/**
 * LOGIN GET ROUTE
 */
app.get('/login', (req,res) => {
  res.render('login.ejs', { clientid: CLIENTID });
})

/**
 * LOGIN POST ROUTE
 */
app.post('/login', async (req,res) => {
  try {
    let userinfo = await helpers.verifyLogin(req.body.credential, CLIENTID);

    req.session.loggedIn = true;
    req.session.username = userinfo.givenname;
    req.session.userid = userinfo.uid;

    res.redirect('/');
  } catch {
    res.send("invalid login");
  }
})

// LOGOUT ROUTE
app.post('/logout', (req,res) => {
  delete req.session;
  res.redirect('/');
})

// Forces the server to quit when CTRL+C is pressed
process.on('SIGINT', function() {
  process.exit(0);
});

app.listen(PORT, async () => {
  console.log(`server listening on port ${PORT}...`);

  // Upload the logos being used to the cloud before any
  //  pages are loaded
  const TMPIMGDIR = process.env.NODE_ENV == "production" ? "" : __dirname + "/";
  await storage.bucket(BUCKET).upload(TMPIMGDIR + "wvs logo.PNG");
  await storage.bucket(BUCKET).upload(TMPIMGDIR + "wvs logo favicon.ico");
})